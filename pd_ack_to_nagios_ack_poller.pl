#!/usr/bin/perl

######################################################################
# script to poll pagerduty for new acks to alerts generated by pagerduty_nagios.pl
# https://github.com/PagerDuty/pagerduty-nagios-pl
#
# it's handy to ack nagios alerts from pagerduty's sms or phone
# interface the same way you might for an email alert.  this will get
# acks to nagios alerts fed back to nagios
#
# also a resolve in pagerduty will create an ack in nagios
######################################################################

######################################################################
#Permission is hereby granted, free of charge, to any person
#obtaining a copy of this software and associated documentation
#files (the "Software"), to deal in the Software without
#restriction, including without limitation the rights to use,
#copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the
#Software is furnished to do so, subject to the following
#conditions:
#
#The above copyright notice and this permission notice shall be
#included in all copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#OTHER DEALINGS IN THE SOFTWARE.
######################################################################

use Getopt::Long;
use JSON;
use Data::Dumper;
use strict;
use Scalar::Util qw(looks_like_number);
use File::Temp qw(tempfile);

my(%opts);
my(@opts)=('debug',
           'nagios_status_file|s=s',
           'nagios_command_pipe|c=s',
           'pagerduty_token|p=s',
           'pagerduty_token_file|f=s',
           'pagerduty_service|n=s',
           'days_back|t=s',
           'help|h',
    );

die unless GetOptions(\%opts,@opts);

if($opts{help}){
  print <<EOT;
$0: pass pagerduty acknowledgements into nagios

options:

 --debug | -d
 --nagios_status_file <_file> | -s <_file> (default /var/cache/nagios/status.dat)
 --nagios_command_pipe <_file> | -c <_file> (default /var/spool/nagios/cmd/nagios.cmd)
 --pagerduty_token <_token> | -p <_token>
 --pagerduty_token_file <_file> | -f <_file> (default /etc/nagios/pd_ack_to_nagios_ack_poller.key)
 --pagerduty_service <_service> | -n <_service> (limit to a comma separated list of service ids)
 --days_back <_days> | -t <_service> (the amount of time in days in the past to look for Nagios incidents - default and minimum value is 1)
 --help | -h (this message)
EOT
exit 0;
}

$opts{nagios_status_file} ||= '/var/cache/nagios/status.dat';
$opts{nagios_command_pipe} ||= '/var/spool/nagios/cmd/nagios.cmd';
$opts{days_back} ||= '1';

die "can't access pipe $opts{nagios_command_pipe}" if(!(-w $opts{nagios_command_pipe}));
die "--pagerduty_token|-p or --pagerduty_token_file|-f required" unless($opts{pagerduty_token} || $opts{pagerduty_token_file});
die "days back must be an integer greater than zero" unless(looks_like_number($opts{days_back}));

my($days_back) = int($opts{days_back});

# create temp file for our auth token - removed when program exits
my $tmp_fh = new File::Temp( UNLINK => 1 );

if(!defined($opts{pagerduty_token})) {
  $opts{pagerduty_token_file} ||= '/etc/nagios/pd_ack_to_nagios_ack_poller.key';
  open(FILE, $opts{pagerduty_token_file}) || die "can't open pagerduty_token_file, and no token has been passed on the command line";
  die "pagerduty_token_file is empty, and no token has been passed on the command line"
    if(-z $opts{pagerduty_token_file});
  $opts{pagerduty_token} = <FILE>;
  close(FILE);
  chomp($opts{pagerduty_token});

  # now we need to convert that raw token file into something curl can use with an Authorization Token header
  # man curl -> -H, --header <header/@file>
  print $tmp_fh "Authorization: Token token=$opts{pagerduty_token}";
}

# optionally specify service id(s)
my($svcparam) = "";
if(defined($opts{pagerduty_service})){
    $svcparam = "&service=$opts{pagerduty_service}";
}

my($cmd);

print "Retrieve all services with problems from the Nagios status file\n" if($opts{debug});
# retrieve all services with problems from the Nagios status file
my($nagstat) = {};
$cmd = "cat $opts{nagios_status_file} | grep -A50 'servicestatus {'" .
    "| egrep 'servicestatus|host_name|service_description|current_problem_id|problem_has_been_acknowledged' " .
    "| cut -d= -f2";
print "$cmd\n" if($opts{debug});
my(@statcat) = `$cmd`;
print "@statcat\n" if($opts{debug});

# build a map with key hostname-service and the Nagios problem id
print "Unack'd Nagios Services:\n" if($opts{debug});
while(@statcat){
  chomp(my(undef, $h, $s, $pi, $a) = (shift(@statcat), shift(@statcat), shift(@statcat), shift(@statcat), shift(@statcat)));
  next if($a != 0);
  next if($pi == 0);
  print "Host:           $h\n" if($opts{debug});
  print "Service:        $s\n" if($opts{debug});
  print "Problem ID:     $pi\n" if($opts{debug});
  print "Ack'd? (0=not): $a\n" if($opts{debug});
  $nagstat->{$h}{$s} = $pi;
}
print "----------------\n" if($opts{debug});

print "Retrieve all hosts with problems from the Nagios status file\n" if($opts{debug});
# retrieve all hosts with problems from the Nagios status file
$cmd = "cat $opts{nagios_status_file} | grep -A50 'hoststatus {'" .
    "| egrep 'host_name|current_problem_id|problem_has_been_acknowledged' " .
    "| cut -d= -f2";
print "$cmd\n" if($opts{debug});
my(@statcat) = `$cmd`;
print "@statcat\n" if($opts{debug});

# build a map with key hostname-HOST and the Nagios problem id
print "Unack'd Nagios Hosts:\n" if($opts{debug});
while(@statcat){
  chomp(my($h, $pi, $a) = (shift(@statcat), shift(@statcat), shift(@statcat)));
  next if($a != 0);
  next if($pi == 0);
  print "Host:           $h\n" if($opts{debug});
  print "Problem ID:     $pi\n" if($opts{debug});
  print "Ack'd? (0=not): $a\n" if($opts{debug});
  $nagstat->{$h}{HOST} = $pi;
}
print "----------------\n" if($opts{debug});
print "All Nagios Hosts and Services with issues and issue number:\n" if($opts{debug});
print Dumper $nagstat if($opts{debug});
print "----------------\n\n" if($opts{debug});

my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime(time - (86400 * $days_back));
$mon += 1;
$year += 1900;
my($dateforquery) = sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", $year, $mon, $mday, $hour, $min, $sec);

# retrieve all resolved and acknowledged incidents from pagerduty in reverse order by id
my($limit,$offset,$more);
$limit = 100;
$more = 'true';
$offset = 0;


my($j);
while ($more eq 'true')
{
  $cmd = "curl -s -H \@${tmp_fh} " .
      "'https://api.pagerduty.com/incidents?limit=$limit&offset=$offset&fields=incident_number,id" .
      "${svcparam}&statuses%5B%5D=acknowledged&statuses%5B%5D=resolved&since=$dateforquery&sort_by=incident_number:desc" .
      "&include%5B%5D=first_trigger_log_entries'";
  print "PD API Command to get Incidents:\n$cmd\n" if($opts{debug});
  $j = scalar(`$cmd`);
  my($i) = from_json($j, {allow_nonref=>1});
  $more = $i->{more};
  print "more:$more\n" if($opts{debug});
  $offset += $limit;
  my($skipThisOne);

  # loop over PagerDuty incidents retrieved earlier, if any have an ack'd or resolved Nagios log entry, check if the problem ids match and then ack in Nagios
  for(reverse(@{$i->{incidents}})) {
    my($in) = $_->{incident_number};
    my($iid) = $_->{id};

    if ($_->{first_trigger_log_entry}{channel}{type} eq 'nagios') #ignore if PD incident was not initiated by Nagios
    { 
      print "\nPD Incident number: $in\n" if($opts{debug});

      # retrieve the log entries for the incident
      $cmd = "curl -s -H \@${tmp_fh} ".
          "'https://api.pagerduty.com/incidents/$iid/log_entries?is_overview=true&limit=100'";
      print "PD API Command to get log_entries:\n$cmd\n" if($opts{debug});
      $j = scalar(`$cmd`);
      my($ls) = from_json($j, {allow_nonref=>1});
      print Dumper $ls if($opts{debug});

      $skipThisOne = 0;

      # skip if this is not a nagios alert
      $skipThisOne ||= !($ls->{log_entries}[$#{$ls->{log_entries}}]{channel}{type} eq 'nagios');

      # filter out non-ack/resolve
      my($lf) = [grep {$_->{type} =~ /^(resolve_log_entry|acknowledge_log_entry)/} @{$ls->{log_entries}}];
      
      # skip if nagios ack/resolution came from nagios
      $skipThisOne ||= ($lf->[0]{channel}{type} eq 'nagios');

      # skip if resolution was a timeout
      $skipThisOne ||= ($lf->[0]{channel}{type} eq 'timeout');

      if (!($skipThisOne))
      {
        my($u) = $lf->[0]{agent}{summary};
        # my($u) = $lf->[0]{agent}{email} =~ /^([^\@]*)\@/;
        my($c) = $lf->[0]{channel}{type};
        my($lt) = $lf->[0]{type};
        my($li) = $ls->{log_entries}[$#{$ls->{log_entries}}]{id};

        # Get the channel data for this log entry which contains the custom fields
        $cmd = "curl -s -H \@${tmp_fh} " .
            "'https://api.pagerduty.com/log_entries/$li?include%5B%5D=channels'";
        print "PD API Command to get custom fields from log_entries:\n$cmd\n" if($opts{debug});

        $j = scalar(`$cmd`);
        my($raw) = from_json($j, {allow_nonref=>1});
        print Dumper $raw->{log_entry}{channel}{details} if($opts{debug});

        # get the HOST and SERVICE info
        my($h) = $raw->{log_entry}{channel}{details}{HOSTNAME};
        #my($h) = $raw->{log_entry}{channel}{details}{HOSTDISPLAYNAME};
        my($s) = $raw->{log_entry}{channel}{details}{SERVICEDESC};
        #my($s) = $raw->{log_entry}{channel}{details}{SERVICEDISPLAYNAME};
        my($hpi) = $raw->{log_entry}{channel}{details}{HOSTPROBLEMID};
        my($spi) = $raw->{log_entry}{channel}{details}{SERVICEPROBLEMID};

        # skip if there's no problem id in nagios (meaning service is
        # already recovered), or if the problem id is more recent than
        # the one in the raw pagerduty entry.
        print "Custom Detail Fields found in PD Incident:\n" if($opts{debug});
        print " host name:    '$h'\n" if($opts{debug});
        print " service name: '$s'\n" if($opts{debug});
        print "\nLook for UNACK'D Nagios problem on that host:\n" if($opts{debug});
        print " host problem id from Nagios:    '$nagstat->{$h}{HOST}'\n" if($opts{debug});
        print " host problem id from PagerDuty: '$hpi'\n" if($opts{debug});

        # first check for any host problems
        if($nagstat->{$h}{HOST} && ($nagstat->{$h}{HOST} <= $hpi)){
          my($t) = time;
          #ACKNOWLEDGE_HOST_PROBLEM;<host_name>;<sticky>;<notify>;<persistent>;<author>;<comment>
          $cmd = "echo '[$t] ACKNOWLEDGE_HOST_PROBLEM;$h;1;0;1;$u;pd event $in $lt by $u via $c' >$opts{nagios_command_pipe}";
          print "Sending Host Acknowledge command to Nagios:\n$cmd\n" if($opts{debug});
          # call the command line executable to acknowledge in Nagios
          `$cmd`;
        } else {
          print "No UNACK'D Host problem found in Nagios on host '$h'\n" if($opts{debug});
        }
        print "\nLook for UNACK'D Nagios problem on that host and service:\n" if($opts{debug});
        print " service problem id from Nagios:    '$nagstat->{$h}{$s}'\n" if($opts{debug});
        print " service problem id from PagerDuty: '$spi'\n" if($opts{debug});

        # then check for any service problems
        if($nagstat->{$h}{$s} && ($nagstat->{$h}{$s} <= $spi)){
          my($t) = time;
          #ACKNOWLEDGE_SVC_PROBLEM;<host_name>;<service_description>;<sticky>;<notify>;<persistent>;<author>;<comment>
          $cmd = "echo '[$t] ACKNOWLEDGE_SVC_PROBLEM;$h;$s;1;0;1;$u;pd event $in $lt by $u via $c' >$opts{nagios_command_pipe}";
          print "Sending Service Acknowledge command to Nagios:\n$cmd\n" if($opts{debug});
          # call the command line executable to acknowledge in Nagios
          `$cmd`;
        } else {
          print "No UNACK'D Service problem found in Nagios on host '$h' and service '$s'\n" if($opts{debug});
        }
      }
    }
    else
    {
      print "Skipping PD incident $in\n" if($opts{debug});
    }
  }
}
